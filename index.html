<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Custom Map Viewer</title>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: #f0f0f0;
            height: 100vh;
            overflow: hidden;
        }
        
        .container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        #mapContainer {
            width: 100%;
            height: 100vh;
            background: #1e3a5f;
            position: relative;
            overflow: hidden;
        }
        
        #mapSvg {
            width: 100%;
            height: 100%;
            cursor: move;
        }
        
        .country {
            stroke: #333;
            stroke-width: 1;
            transition: all 0.3s;
            cursor: pointer;
        }
        
        .country:hover {
            stroke: #fff;
            stroke-width: 3;
            filter: brightness(1.2);
        }
        
        .country-highlighted {
            stroke: #fff !important;
            stroke-width: 4 !important;
            filter: brightness(1.3) !important;
            z-index: 10;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
        }
        
        .status {
            padding: 10px;
            margin-top: 15px;
            border-radius: 4px;
            text-align: center;
            font-weight: bold;
        }
        
        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            backdrop-filter: blur(5px);
            z-index: 200;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .legend h4 {
            margin: 0 0 10px 0;
            color: #333;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .legend-color {
            width: 20px;
            height: 15px;
            margin-right: 10px;
            border: 1px solid #333;
        }
        
        .legend-text {
            font-size: 12px;
            color: #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="mapContainer">
            <svg id="mapSvg" xmlns="http://www.w3.org/2000/svg">
                <g id="mapGroup" transform="translate(0,0) scale(1)"></g>
            </svg>
            <div class="tooltip" id="tooltip" style="display: none;"></div>
            <div class="legend" id="legend" style="display: none;">
                <h4>Alliances</h4>
                <div id="legendContent"></div>
            </div>
        </div>
    </div>

    <!-- Shapefile.js for reading shapefiles -->
    <script src="https://unpkg.com/shpjs@latest/dist/shp.js"></script>
    
    <script>
        let mapData = null;
        let scale = 1;
        let translateX = 0;
        let translateY = 0;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let affiliationColors = {};
        
        // Predefined colors for affiliations
        const colorPalette = [
            '#259ede', '#88bbf2', '#ffc000', '#ab2bd6', '#2cc71c',
            '#91e887', '#a5fffc', '#de2424', '#f28787', '#bfbfbf'
        ];
        
        // fixing errors
        const allianceNameMap = {
            'USAA': 'American Bloc',
            'RUSA': 'Russian Bloc',
            'USA': 'America',
            'RUS': 'Russia'
        };
        
        const countryNameMap = {
            'Outer Mongolia': 'Outer Uzbekistan'
        };
        
        // Function to get display name for alliance
        function getDisplayName(originalName) {
            return allianceNameMap[originalName] || originalName;
        }
        
        // Function to get display name for country
        function getCountryDisplayName(originalName) {
            return countryNameMap[originalName] || originalName;
        }
        
        // Function to format numbers with commas
        function formatNumber(num) {
            if (!num || num === 'Unknown') return num;
            return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        }
        
        // Generate colors for affiliations
        function generateAffiliationColors(features) {
            const affiliations = new Set();
            features.forEach(feature => {
                if (feature.properties?.Affill) {
                    affiliations.add(feature.properties.Affill);
                }
            });
            
            const affiliationList = Array.from(affiliations).sort();
            affiliationList.forEach((affill, index) => {
                affiliationColors[affill] = colorPalette[index % colorPalette.length];
            });
            
            return affiliationList;
        }
        
        // Create legend
        function createLegend(affiliationList) {
            const legendContent = document.getElementById('legendContent');
            legendContent.innerHTML = '';
            
            affiliationList.forEach(affill => {
                const item = document.createElement('div');
                item.className = 'legend-item';
                
                const colorBox = document.createElement('div');
                colorBox.className = 'legend-color';
                colorBox.style.backgroundColor = affiliationColors[affill];
                
                const text = document.createElement('div');
                text.className = 'legend-text';
                text.textContent = getDisplayName(affill);
                
                item.appendChild(colorBox);
                item.appendChild(text);
                legendContent.appendChild(item);
            });
            
            document.getElementById('legend').style.display = 'block';
        }
        
        // Show status message
        function showStatus(message, type) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
            statusEl.style.display = 'block';
        }
        
        // Convert shapefile coordinates to SVG coordinates
        function convertCoords(coords, bounds, svgWidth, svgHeight) {
            const scaleX = svgWidth / (bounds.maxX - bounds.minX);
            const scaleY = svgHeight / (bounds.maxY - bounds.minY);
            const useScale = Math.min(scaleX, scaleY) * 0.9; // 90% to leave margins
            
            function convertPoint(point) {
                const x = (point[0] - bounds.minX) * useScale + (svgWidth - (bounds.maxX - bounds.minX) * useScale) / 2;
                const y = svgHeight - ((point[1] - bounds.minY) * useScale + (svgHeight - (bounds.maxY - bounds.minY) * useScale) / 2);
                return [x, y];
            }
            
            if (coords[0] && Array.isArray(coords[0]) && Array.isArray(coords[0][0])) {
                // Polygon with holes
                return coords.map(ring => ring.map(convertPoint));
            } else if (coords[0] && Array.isArray(coords[0])) {
                // Simple polygon
                return coords.map(convertPoint);
            } else {
                // Single point
                return convertPoint(coords);
            }
        }
        
        // Create SVG path from coordinates
        function createPath(coords) {
            if (!coords || coords.length === 0) return '';
            
            if (coords[0] && Array.isArray(coords[0]) && Array.isArray(coords[0][0])) {
                // Polygon with holes
                return coords.map(ring => {
                    return 'M ' + ring.map(p => p[0] + ',' + p[1]).join(' L ') + ' Z';
                }).join(' ');
            } else {
                // Simple polygon
                return 'M ' + coords.map(p => p[0] + ',' + p[1]).join(' L ') + ' Z';
            }
        }
        
        // Render the map
        function renderMap(geojson) {
            console.log('Rendering map with features:', geojson.features.length);
            
            const svg = document.getElementById('mapSvg');
            const mapGroup = document.getElementById('mapGroup');
            const svgRect = svg.getBoundingClientRect();
            
            // Calculate bounds
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            
            geojson.features.forEach(feature => {
                if (feature.geometry && (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon')) {
                    let polygons = [];
                    if (feature.geometry.type === 'Polygon') {
                        polygons = [feature.geometry.coordinates];
                    } else if (feature.geometry.type === 'MultiPolygon') {
                        polygons = feature.geometry.coordinates;
                    }
                    
                    polygons.forEach(polygon => {
                        if (polygon && polygon[0]) {
                            polygon[0].forEach(coord => {
                                minX = Math.min(minX, coord[0]);
                                minY = Math.min(minY, coord[1]);
                                maxX = Math.max(maxX, coord[0]);
                                maxY = Math.max(maxY, coord[1]);
                            });
                        }
                    });
                }
            });
            
            const bounds = { minX, minY, maxX, maxY };
            console.log('Data bounds:', bounds);
            
            // Generate colors for affiliations
            const affiliationList = generateAffiliationColors(geojson.features);
            
            // Clear existing content
            mapGroup.innerHTML = '';
            
            // Render each country
            let validFeatures = 0;
            geojson.features.forEach((feature, index) => {
                if (feature.geometry && (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') && feature.geometry.coordinates) {
                    
                    // Handle both Polygon and MultiPolygon
                    let polygons = [];
                    if (feature.geometry.type === 'Polygon') {
                        polygons = [feature.geometry.coordinates];
                    } else if (feature.geometry.type === 'MultiPolygon') {
                        polygons = feature.geometry.coordinates;
                    }
                    
                    // Create a path for each polygon part
                    polygons.forEach((polygon, polygonIndex) => {
                        if (polygon && polygon[0]) {
                            const convertedCoords = convertCoords(polygon[0], bounds, svgRect.width, svgRect.height);
                            const pathData = createPath(convertedCoords);
                            
                            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                            path.setAttribute('d', pathData);
                            path.setAttribute('class', 'country');
                            
                            // Set color based on affiliation
                            const affiliation = feature.properties?.Affill || 'Unknown';
                            const fillColor = affiliationColors[affiliation] || '#CCCCCC';
                            path.style.fill = fillColor;
                            
                            path.setAttribute('data-name', feature.properties?.Name || `Country ${index + 1}`);
                            path.setAttribute('data-affill', affiliation);
                            path.setAttribute('data-population', feature.properties?.Population || 'Unknown');
                            
                            // Mouse events for tooltip
                            path.addEventListener('mouseenter', showTooltip);
                            path.addEventListener('mouseleave', hideTooltip);
                            path.addEventListener('mousemove', updateTooltip);
                            
                            mapGroup.appendChild(path);
                        }
                    });
                    
                    validFeatures++;
                } else {
                    console.warn(`Skipping feature ${index} - invalid or null geometry:`, feature);
                }
            });
            
            // Create legend
            createLegend(affiliationList);
            
            console.log(`Successfully loaded ${validFeatures} countries (${geojson.features.length} total features)`);
        }
        
        // Tooltip functions
        function showTooltip(event) {
            const tooltip = document.getElementById('tooltip');
            const name = event.target.getAttribute('data-name');
            const affill = event.target.getAttribute('data-affill');
            const population = event.target.getAttribute('data-population');
            
            // Highlight all parts of the same country
            highlightCountryParts(name);
            
            tooltip.innerHTML = `
                <strong>${getCountryDisplayName(name)}</strong><br>
                Affiliation: ${getDisplayName(affill)}<br>
                Population: ${formatNumber(population)}
            `;
            tooltip.style.display = 'block';
            updateTooltip(event);
        }
        
        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
            // Remove highlighting from all countries
            clearHighlights();
        }
        
        function highlightCountryParts(countryName) {
            // Clear any existing highlights
            clearHighlights();
            
            // Find and highlight all parts with the same country name
            const allCountries = document.querySelectorAll('.country');
            allCountries.forEach(country => {
                if (country.getAttribute('data-name') === countryName) {
                    country.classList.add('country-highlighted');
                }
            });
        }
        
        function clearHighlights() {
            const highlightedCountries = document.querySelectorAll('.country-highlighted');
            highlightedCountries.forEach(country => {
                country.classList.remove('country-highlighted');
            });
        }
        
        function updateTooltip(event) {
            const tooltip = document.getElementById('tooltip');
            tooltip.style.left = (event.clientX + 10) + 'px';
            tooltip.style.top = (event.clientY - 10) + 'px';
        }
        
        // Zoom and pan functions
        function zoomIn() {
            scale *= 1.2;
            updateTransform();
        }
        
        function zoomOut() {
            scale /= 1.2;
            updateTransform();
        }
        
        function resetView() {
            scale = 1;
            translateX = 0;
            translateY = 0;
            updateTransform();
        }
        
        function updateTransform() {
            const mapGroup = document.getElementById('mapGroup');
            mapGroup.setAttribute('transform', `translate(${translateX}, ${translateY}) scale(${scale})`);
        }
        
        // Pan functionality
        document.getElementById('mapSvg').addEventListener('mousedown', function(e) {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });
        
        document.addEventListener('mousemove', function(e) {
            if (isDragging) {
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;
                translateX += deltaX;
                translateY += deltaY;
                updateTransform();
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        });
        
        document.addEventListener('mouseup', function() {
            isDragging = false;
        });
        
        // Mouse wheel zoom functionality
        document.getElementById('mapSvg').addEventListener('wheel', function(e) {
            e.preventDefault();
            
            const rect = e.currentTarget.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Calculate zoom factor
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            
            // Zoom towards mouse position
            const newScale = scale * zoomFactor;
            
            // Adjust translation to zoom towards mouse position
            translateX = mouseX - (mouseX - translateX) * (newScale / scale);
            translateY = mouseY - (mouseY - translateY) * (newScale / scale);
            
            scale = newScale;
            updateTransform();
        });
        
        // Load default shapefile
        async function loadDefaultMap() {
            console.log('Loading default map...');
            
            try {
                const response = await fetch('map_v7.zip');
                if (response.ok) {
                    const arrayBuffer = await response.arrayBuffer();
                    const geojson = await shp(arrayBuffer);
                    console.log('Loaded default GeoJSON:', geojson);
                    mapData = geojson;
                    renderMap(geojson);
                } else {
                    console.error('Could not load default map. Response status:', response.status);
                }
            } catch (error) {
                console.error('Error loading default map:', error);
            }
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            // Load default map automatically
            setTimeout(() => {
                loadDefaultMap();
            }, 500);
        });
    </script>
</body>
</html>